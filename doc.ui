// types
Boolean // either `true` or `false`
Int // an 32-bit integer, e.g. `800`
Float // a floating point number, e.g. `-10.5`
String // a string, e.g. `"hello world"` TBD: escape sequences and/or HTML entities
Length // a representation of the distance between two points in coordinate space
       // e.g., `8px`, `2.5in`
Alignment // position hint for items within rows or columns. enum: `.stretch`, `.start`, `.center`, `.end`
Color // a color, e.g.`#ff0`, `rgba(200, 100, 300, 0.5)`, `.red`
Brush // a color, gradient, or image data (TBD except color)
[<type>] // [String] a collection of some type. e.g., `["a","b","c"]`
{ <name>: <type>; ... } // { x: Length; y: Length } a collection of named, strongly typed properties
                        // e.g., `{ x 20px; y: 100px }`





// rect draws a positioned rectangle with the specified background brush
rect {
    clip: Boolean = true; // clip children outside the element's bounding box
    x: Length = 0; // x coordinate within the parent element
    y: Length = 0; // y coordinate within the parent element
    width: Length = 0; // width of the element
    height: Length = 0; // height of the element
    background: Brush = .transparent; // the background fill of the element
    rounded: Length = 0; // the radius of the rect's rounded corners
    border: {
        width: Length = 0; // width of the rect's border. Can be overriden by individual side settings
        color: Color = .black; // color of the rect's border. Can be overriden by individual side settings
        top: {
            width: Length = (self.border.width); // width of the rect's top border
            color: Color = (self.border.color); // color of the rect'stop  border
        }
        right: {
            width: Length = (self.border.width); // width of the rect's right border
            color: Color = (self.border.color); // color of the rect's right border
        }
        bottom: {
            width: Length = (self.border.width); // width of the rect's bottom border
            color: Color = (self.border.color); // color of the rect's bottom border
        }
        left: {
            width: Length = (self.border.width); // width of the rect's left border
            color: Color = (self.border.color); // color of the rect's left border
        }
    }
}

// row.stretch is for horizontally laying out items while stretching them to fill the width of the layout.
// Its height can either be "unset," in which case the children will determine the height, or it can be
// set, causing children to be stretched vertically as well.
row.stretch {
    clip: Boolean = true; // clip children outside the element's bounding box
	x: Length = 0; // x coordinate within the parent element
	y: Length = 0; // y coordinate within the parent element
	width: Length = 0; // width of the element
	height: Length = <bound to child state>; // height of the element (by default bound to the max of child heights)
	
	// alters children in the following ways:
	some_child {
		align: Alignment = .stretch; // aligns the item vertically within the row
		stretch: Float = 1; // applies a "stretch factor" to the item. width is disabled unless stretch is 0
	}
}

// column.stretch opposite of row.stretch: it is for vertically laying out items while stretching them
// to fill the height of the layout. Its width can either be "unset," in which case the children will
// determine the width, or it can be set, causing children to be stretched horizontally as well.
column.stretch {
    clip: Boolean = true; // clip children outside the element's bounding box
	x: Length = 0; // x coordinate within the parent element
	y: Length = 0; // y coordinate within the parent element
	width: Length = <bound to child state>; // width of the element (by default bound to the max of child widths)
	height: Length = 0; // height of the element
	
	// adds the following items to children:
	some_child {
		align: Alignment = .stretch; // aligns the item horizontally within the column
		stretch: Float = 1; // applies a "stretch factor" to the item. height is disabled unless stretch is 0
	}
}

// row.grow is for horizontally laying out sized items. Its width cannot be set; its horizontal size
// is determined by its children. Its height can either be "unset," in which case the children will
// determine the height, or it can be set, causing children to be stretched vertically.
row.grow {
    clip: Boolean = true; // clip children outside the element's bounding box
	x: Length = 0; // x coordinate within the parent element
	y: Length = 0; // y coordinate within the parent element
	height: Length = <bound to child state>; // height of the element (by default bount to the max of child heights)

    // adds the following items to children:
	some_child {
		align: Alignment = .stretch; // aligns the item vertically within the row
	}
}

// column.grow is the opposite of row.grow: it is for vertically laying out sized items. Its height
// cannot be set; its vertical size is determined by its children. Its width can either be "unset,"
// in which case the children will determine the width, or it can be set, causing children to be
// stretched horizontally.
column.grow {
    clip: Boolean = true; // clip children outside the element's bounding box
    x: Length = 0; // x coordinate within the parent element
	y: Length = 0; // y coordinate within the parent element
	width: Length = <bound to child state>; // width of the element (by default bount to the max of child widths)

    // adds the following items to children:
	some_child {
		align: Alignment = .stretch; // aligns the item horizontally within the column
	}
}
